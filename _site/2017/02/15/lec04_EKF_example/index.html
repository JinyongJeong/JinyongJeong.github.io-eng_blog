<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"><title>[SLAM] Extended Kalman Filter(EKF) 예제 &middot; Jinyong Jeong</title><meta name="description" content="Robot의 실제 모델을 이용하여 EKF를 설명. "> <!--[if gt IE 8]><!----><style> article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}html,body{margin:0;padding:0}html{line-height:1.65}body{color:#515151;background-color:#fff}a{text-decoration:none}img{display:block;max-width:100%;margin:0 0 1rem}img.lead{max-width:calc(100% + 2rem);width:calc(100% + 2rem);margin-left:calc(-1rem);margin-right:calc(-1rem)}h1,h2,h3,h4,h5,h6{margin-bottom:.5rem;font-weight:600;line-height:1.25;color:#313131;text-rendering:optimizeLegibility}h1{font-size:2rem}h2{margin-top:1rem;font-size:1.5rem}p{margin-top:0;margin-bottom:1rem}p.lead{font-size:1.25rem;font-weight:300}ul,ol,dl{margin-top:0;margin-bottom:1rem}hr{position:relative;margin:1.5rem 0;border:0;border-top:1px solid #eee;border-bottom:1px solid #fff}.container{max-width:38rem;padding-left:1rem;padding-right:1rem;margin-left:auto;margin-right:auto}.page-title,.post-title{color:#303030}.page-title,.post-title{margin-top:0}.post-date{display:block;margin-top:-.25rem;margin-bottom:1rem;color:#9a9a9a;font-weight:bold}.related{padding-top:2rem;padding-bottom:2rem}.related-posts{padding-left:0;list-style:none}.related-posts>li{margin-top:1rem}.related-posts>li>*{font-weight:normal}.message{margin-bottom:1rem;padding:1rem;color:#717171;background-color:#f9f9f9;margin-left:-1rem;margin-right:-1rem}body{padding-left:0.5rem}@media (min-width: 48em){html{font-size:16px}body{padding-left:0}}@media (min-width: 58em){html{font-size:18px}}.sr-only{display:none}.backdrop{display:none}.sidebar{position:relative;z-index:4;padding:2rem 1rem;color:rgba(255,255,255,0.75);background-color:#202020;text-align:left;background-size:cover;background-position:center center;min-height:640px;min-height:100vh;margin-left:-0.5rem}.sidebar a{color:#fff}.sidebar ul{list-style:none;padding-left:0}.sidebar-sticky{position:absolute;right:1rem;bottom:1rem;left:1rem}.sidebar-about>h1{color:#fff;font-size:2rem}.sidebar-nav-item{font-weight:bold;display:block;line-height:1.75;padding:.25rem .1rem;border-top:1px solid rgba(255,255,255,0.23)}.sidebar-social>ul{min-height:3.5rem}.sidebar::before{content:"";position:absolute;top:0;left:0;bottom:0;right:0;background:rgba(32,32,32,0.33);background:-moz-linear-gradient(bottom, rgba(32,32,32,0) 0%, rgba(32,32,32,0.5) 100%);background:-webkit-linear-gradient(bottom, rgba(32,32,32,0) 0%, rgba(32,32,32,0.5) 100%);background:linear-gradient(to bottom, rgba(32,32,32,0) 0%, rgba(32,32,32,0.5) 100%)}@media (min-width: 48em){.sidebar{position:fixed;top:0;left:0;bottom:0;width:18rem;margin-left:0}}.menu{display:block;padding:1.25rem 1.5rem;color:#9a9a9a;border-bottom:none;position:fixed;top:0;left:0;z-index:2}@media (min-width: 48em){.menu{position:absolute;left:-9999px}}@media (min-width: 48em){.menu:focus{left:19.5rem}}@media (min-width: 64em){.menu:focus{left:21.5rem}}.content{padding-top:4rem;padding-bottom:4rem}@media (min-width: 48em){.content{max-width:38rem;margin-left:20rem;margin-right:2rem;border-left:none}}@media (min-width: 64em){.content{margin-left:22rem;margin-right:4rem}}.me{float:right;width:6.5rem;margin-top:-4.8rem;margin-left:1rem;border-radius:100%;position:relative}@media (min-width: 38em){.me{width:7rem;margin-top:-5.05rem}}@media (min-width: 48em){.me{width:6.5rem;margin-top:-4.8rem}}@media (min-width: 58em){.me{width:7rem;margin-top:-5.05rem}}</style><noscript><link rel="stylesheet" href="http://JinyongJeong.github.io/public/css/non-essentials.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab:700|PT+Serif:400,400italic,700,700italic"><link rel="stylesheet" href="http://JinyongJeong.github.io/public/css/icons.css"> </noscript><link rel="preload" href="http://JinyongJeong.github.io/public/css/non-essentials.css" as="style" onload="this.rel='stylesheet'"><style> html { font-family: "PT Serif", Georgia, serif; } :focus { outline-color: #949667; } .font-accent { font-family: "Roboto Slab", "PT Serif", Georgia, serif; } .content a, .related-posts li a:hover { color: #949667; } ::selection { color: #fff; background: #949667; } ::-moz-selection { color: #fff; background: #949667; } .sidebar { background-image: url('/public/img/2.jpg'); }</style><!--<![endif]--><link rel="canonical" href="http://localhost:4000http://JinyongJeong.github.io/2017/02/15/lec04_EKF_example/" /><link rel="alternate" type="application/atom+xml" title="Jinyong Jeong Atom Feed" href="http://JinyongJeong.github.io/atom.xml"> <script>!function(n,e){function t(n,e){n.onload=function(){this.onerror=this.onload=null,e(null,n)},n.onerror=function(){this.onerror=this.onload=null,e(new Error("Failed to load "+this.src),n)}}function o(n,e){n.onreadystatechange=function(){"complete"!=this.readyState&&"loaded"!=this.readyState||(this.onreadystatechange=null,e(null,n))}}n.isReady=!1,n.loadJSDeferred=function(a,r){function d(){n.isReady=!0;var d=e.createElement("script");d.src=a,r&&(("onload"in d?t:o)(d,r),d.onload||t(d,r));var i=e.getElementsByTagName("script")[0];i.parentNode.insertBefore(d,i)}n.isReady?d():n.addEventListener?n.addEventListener("load",d,!1):n.attachEvent?n.attachEvent("onload",d):n.onload=d}}(window,document); </script> <!--[if lt IE 9]> <script src="https://unpkg.com/html5shiv/dist/html5shiv.min.js"></script> <![endif]--><body> <span class="sr-only">Jump to:</span> <a id="_menu" class="menu" href="#_asidebar"> <span>☰</span> <span class="sr-only">Menu</span> </a><main class="content container" role="main"><article id="post-2017/02/15/lec04_EKF_example" class="post" role="article"><h1 class="post-title"> [SLAM] Extended Kalman Filter(EKF) 예제</h1><div class="post-date"> <time datetime="2017-02-15T00:00:00+09:00">02/15/17</time> <span>on <a href="http://JinyongJeong.github.io/tag/SLAM/">SLAM</a></span></div><p class="message">Robot의 실제 모델을 이용하여 EKF를 설명.<hr/><p><strong>본 글은 University Freiburg의 <a href="http://ais.informatik.uni-freiburg.de/teaching/ws13/mapping/">Robot Mapping</a> 강의를 바탕으로 이해하기 쉽도록 정리하려는 목적으로 작성되었습니다. 개인적인 의견을 포함하여 작성되기 때문에 틀린 내용이 있을 수도 있습니다. 틀린 부분은 지적해주시면 확인 후 수정하겠습니다.</strong><p>이번 글에서는 이전 글에서 설명한 Extended Kalman Filter(EKF)를 실제 모델을 이용해서 설명한다. 이전 글을 통해 EKF의 선형화 과정과 bayes filter 과정을 이해했지만 실제 어떻게 적용을 하는지에 대해서는 이해가 잘 되지 않을 수 있다. 이 글에서는 velocity motion model과 observation model을 이용하여 EKF과정을 설명한다.<h3 id="motion-model">Motion model</h3><p>Robot의 Motion model은 크게 두가지로 나뉜다.<ul><li>Odometry-based model<li>Velocity-based model</ul><p>이 글에서는 velocity-based model을 이용하여 설명한다. 아래 그림은 velocity-based model을 보여준다. <code class="MathJax_Preview">x,y,\theta</code><script type="math/tex">x,y,\theta</script>는 로봇의 x,y좌표 및 방향을 의미하며, 로봇의 선속도는 <code class="MathJax_Preview">v</code><script type="math/tex">v</script>, 각속도는 <code class="MathJax_Preview">\omega</code><script type="math/tex">\omega</script>이다.<p><img align="middle" src="/images/post/SLAM/lec04_EKF_example/velocity_model.png" width="100%" /><p>이때 로봇의 상태(state)는 <code class="MathJax_Preview">\mathbf{x_t} = \begin{bmatrix} x \\ y \\ \theta \end{bmatrix}</code><script type="math/tex">\mathbf{x_t} = \begin{bmatrix} x \\ y \\ \theta \end{bmatrix}</script>이며, control input은 <code class="MathJax_Preview">u_t = \begin{bmatrix} v \\ \omega \end{bmatrix}</code><script type="math/tex">u_t = \begin{bmatrix} v \\ \omega \end{bmatrix}</script>이다. 실제 로봇을 이동시키기 위해서는 모터를 구동시켜야 하기 때문에 로봇에 들어가는 실제 입력은 모터를 구동하기 위한 제어값이다. 하지만 여기서 control input은 로봇이 얼마나 이동했는지를 측정하기 위한 센서값을 의미한다. Velocity-based model에서 motion model은 다음과 같다.<pre class="MathJax_Preview"><code>\begin{bmatrix}
x_{t}\\y_{t}\\ \theta_{t}
\end{bmatrix}
=
\begin{bmatrix}
x_{t-1} - \frac{\hat{v_t}}{\hat{\omega_t}} \sin \theta_{t-1} + \frac{\hat{v_t}}{\hat{\omega_t}}\sin(\theta_{t-1} + \hat{\omega_t}\vartriangle t)\\
y_{t-1} - \frac{\hat{v_t}}{\hat{\omega_t}} \cos \theta_{t-1} - \frac{\hat{v_t}}{\hat{\omega_t}}\cos(\theta_{t-1} + \hat{\omega_t}\vartriangle t)\\
\theta_{t-1} + \hat{\omega_t} \vartriangle t
\end{bmatrix}</code></pre><script type="math/tex; mode=display">\begin{bmatrix} x_{t}\\y_{t}\\ \theta_{t} \end{bmatrix} = \begin{bmatrix} x_{t-1} - \frac{\hat{v_t}}{\hat{\omega_t}} \sin \theta_{t-1} + \frac{\hat{v_t}}{\hat{\omega_t}}\sin(\theta_{t-1} + \hat{\omega_t}\vartriangle t)\\ y_{t-1} - \frac{\hat{v_t}}{\hat{\omega_t}} \cos \theta_{t-1} - \frac{\hat{v_t}}{\hat{\omega_t}}\cos(\theta_{t-1} + \hat{\omega_t}\vartriangle t)\\ \theta_{t-1} + \hat{\omega_t} \vartriangle t \end{bmatrix}</script><p>즉 velocity-based model은 비선형 함수로 정의된다. 위 식에서 <code class="MathJax_Preview">\hat{}</code><script type="math/tex">\hat{}</script>은 노이즈를 포함한 control input을 의미한다. control input의 covariance가 <code class="MathJax_Preview">M_t</code><script type="math/tex">M_t</script>일 때 다음과 같이 노이즈를 분리할 수 있다.<pre class="MathJax_Preview"><code>\begin{bmatrix} \hat{v} \\ \hat{\omega} \end{bmatrix}
=
\begin{bmatrix} v \\ \omega \end{bmatrix}+\mathcal{N}(0,M_t)</code></pre><script type="math/tex; mode=display">\begin{bmatrix} \hat{v} \\ \hat{\omega} \end{bmatrix} = \begin{bmatrix} v \\ \omega \end{bmatrix}+\mathcal{N}(0,M_t)</script><p>따라서 노이즈 항을 따로 분리하면 다음과 같이 다시 쓸 수 있다.<pre class="MathJax_Preview"><code>\begin{bmatrix}
x_{t}\\y_{t}\\ \theta_{t}
\end{bmatrix}
=
\begin{bmatrix}
x_{t-1} - \frac{v_t}{\omega_t} \sin \theta_{t-1} + \frac{v_t}{\omega_t}\sin(\theta_{t-1} + \omega_t\vartriangle t)\\
y_{t-1} + \frac{v_t}{\omega_t} \cos \theta_{t-1} - \frac{v_t}{\omega_t}\cos(\theta_{t-1} + \omega_t\vartriangle t)\\
\theta_{t-1} + \omega_t \vartriangle t
\end{bmatrix} + \mathcal{N}(0,R_t)</code></pre><script type="math/tex; mode=display">\begin{bmatrix} x_{t}\\y_{t}\\ \theta_{t} \end{bmatrix} = \begin{bmatrix} x_{t-1} - \frac{v_t}{\omega_t} \sin \theta_{t-1} + \frac{v_t}{\omega_t}\sin(\theta_{t-1} + \omega_t\vartriangle t)\\ y_{t-1} + \frac{v_t}{\omega_t} \cos \theta_{t-1} - \frac{v_t}{\omega_t}\cos(\theta_{t-1} + \omega_t\vartriangle t)\\ \theta_{t-1} + \omega_t \vartriangle t \end{bmatrix} + \mathcal{N}(0,R_t)</script><p>여기서 <code class="MathJax_Preview">R_t</code><script type="math/tex">R_t</script>는 process noise로 control input의 uncertainty에 의해 발생하며, <code class="MathJax_Preview">R_t</code><script type="math/tex">R_t</script>에 대해서는 뒤에서 다시 자세히 설명한다.<p>이제 motion model을 알고 있으므로 앞에서 설명한 Jacobian matrix를 이용하여 선형화된 model을 계산할 수 있다.<pre class="MathJax_Preview"><code>\mathbf{x_t} = G_t \mathbf{x_{t-1}} + V_t \mathbf{u_t}</code></pre><script type="math/tex; mode=display">\mathbf{x_t} = G_t \mathbf{x_{t-1}} + V_t \mathbf{u_t}</script><p>위 식에서 <code class="MathJax_Preview">G_t, V_t</code><script type="math/tex">G_t, V_t</script>는 각각 <code class="MathJax_Preview">\mathbf{x_{t-1}}</code><script type="math/tex">\mathbf{x_{t-1}}</script>와 <code class="MathJax_Preview">\mathbf{u_t}</code><script type="math/tex">\mathbf{u_t}</script>로 편미분을 통해 계산한 Jacobian matrix이다.<pre class="MathJax_Preview"><code>G_t = \frac{\partial g(u_t,\mu_{t-1})}{\partial \mathbf{x_{t-1}}} =
\begin{pmatrix}
1 &amp; 0 &amp; -\frac{v_t}{\omega_t}\cos \theta_{t-1} + \frac{v_t}{\omega_t}\cos(\theta_{t-1}+\omega_t \vartriangle t)\\
0 &amp; 1 &amp; -\frac{v_t}{\omega_t}\sin \theta_{t-1} + \frac{v_t}{\omega_t}\sin(\theta_{t-1}+\omega_t \vartriangle t)\\
0 &amp; 0 &amp; 1
\end{pmatrix}</code></pre><script type="math/tex; mode=display">% <![CDATA[ G_t = \frac{\partial g(u_t,\mu_{t-1})}{\partial \mathbf{x_{t-1}}} = \begin{pmatrix} 1 & 0 & -\frac{v_t}{\omega_t}\cos \theta_{t-1} + \frac{v_t}{\omega_t}\cos(\theta_{t-1}+\omega_t \vartriangle t)\\ 0 & 1 & -\frac{v_t}{\omega_t}\sin \theta_{t-1} + \frac{v_t}{\omega_t}\sin(\theta_{t-1}+\omega_t \vartriangle t)\\ 0 & 0 & 1 \end{pmatrix} %]]></script><pre class="MathJax_Preview"><code>V_t = \frac{\partial g(u_t,\mu_{t-1})}{\partial \mathbf{u_{t}}} =
\begin{pmatrix}
\frac{-\sin \theta_{t-1} + \sin (\theta_{t-1}+\omega_t \vartriangle t)}{\omega_t} &amp; \frac{v_t(\sin \theta_{t-1} - \sin (\theta_{t-1}+\omega_t \vartriangle t))}{\omega_t^2} + \frac{v_t \vartriangle t \cos (\theta_{t-1} + \omega_t \vartriangle t)}{\omega_t}\\
\frac{\cos \theta_{t-1} - \cos (\theta_{t-1}+\omega_t \vartriangle t)}{\omega_t} &amp;
\frac{v_t(-\cos \theta_{t-1} + \cos (\theta_{t-1}+\omega_t \vartriangle t))}{\omega_t^2} + \frac{v_t \vartriangle t \sin (\theta_{t-1} + \omega_t \vartriangle t)}{\omega_t}
\end{pmatrix}</code></pre><script type="math/tex; mode=display">% <![CDATA[ V_t = \frac{\partial g(u_t,\mu_{t-1})}{\partial \mathbf{u_{t}}} = \begin{pmatrix} \frac{-\sin \theta_{t-1} + \sin (\theta_{t-1}+\omega_t \vartriangle t)}{\omega_t} & \frac{v_t(\sin \theta_{t-1} - \sin (\theta_{t-1}+\omega_t \vartriangle t))}{\omega_t^2} + \frac{v_t \vartriangle t \cos (\theta_{t-1} + \omega_t \vartriangle t)}{\omega_t}\\ \frac{\cos \theta_{t-1} - \cos (\theta_{t-1}+\omega_t \vartriangle t)}{\omega_t} & \frac{v_t(-\cos \theta_{t-1} + \cos (\theta_{t-1}+\omega_t \vartriangle t))}{\omega_t^2} + \frac{v_t \vartriangle t \sin (\theta_{t-1} + \omega_t \vartriangle t)}{\omega_t} \end{pmatrix} %]]></script><p>따라서 위에서 계산한 Jacobian matrix을 이용하여 EKF의 prediction step을 다음과 같이 계산할 수 있다.<pre class="MathJax_Preview"><code>\bar{\Sigma_t} = G_t \Sigma_{t-1} G_t^T + V_t M_t V_t^T = G_t \Sigma_{t-1} G_t^T + R_t</code></pre><script type="math/tex; mode=display">\bar{\Sigma_t} = G_t \Sigma_{t-1} G_t^T + V_t M_t V_t^T = G_t \Sigma_{t-1} G_t^T + R_t</script><h3 id="observation-model">Observation model</h3><p>비선형 observation model을 EKF에 적용해 보기 위해서 가상의 로봇을 이용한다. 이 로봇은 3개의 센서를 갖고 있다. 첫번째 센서는 로봇의 위치에서 부터 landmark까지의 euclidean distance를 측정할 수 있다. 두번째, 세번째 센서는 landmark까지의 x방향의 거리와 y방향의 거리를 각각 측정할 수 있다. 로봇의 state는 <code class="MathJax_Preview">\mathbf{\bar{x}_t} = \begin{bmatrix} \bar{x}_t \\ \bar{y}_t \\ \bar{\theta}_t \end{bmatrix}</code><script type="math/tex">\mathbf{\bar{x}_t} = \begin{bmatrix} \bar{x}_t \\ \bar{y}_t \\ \bar{\theta}_t \end{bmatrix}</script>로 표시하며, landmark의 위치는 <code class="MathJax_Preview">\mathbf{m} = \begin{bmatrix} m_x\\m_y \end{bmatrix}</code><script type="math/tex">\mathbf{m} = \begin{bmatrix} m_x\\m_y \end{bmatrix}</script>라고 하자. 이때의 각 센서의 데이터입력 <code class="MathJax_Preview">\mathbf{z}</code><script type="math/tex">\mathbf{z}</script>는 다음과 같다.<pre class="MathJax_Preview"><code>\mathbf{z_t} =
\begin{bmatrix}
z_1\\z_2\\z_3
\end{bmatrix}
=
\begin{bmatrix}
\sqrt{(m_x - x_t)^2+(m_y - y_t)^2}\\
m_x - x_t\\
m_y - y_t
\end{bmatrix}</code></pre><script type="math/tex; mode=display">\mathbf{z_t} = \begin{bmatrix} z_1\\z_2\\z_3 \end{bmatrix} = \begin{bmatrix} \sqrt{(m_x - x_t)^2+(m_y - y_t)^2}\\ m_x - x_t\\ m_y - y_t \end{bmatrix}</script><p>따라서 위 비선형 observation model을 선형화 하기 위해서 Jacobian을 구하면 다음과 같다.<pre class="MathJax_Preview"><code>H_t = \frac{\partial \mathbf{z_t}}{\partial \mathbf{\bar{x}_t}} =
\begin{pmatrix}
\frac{-m_x+\bar{x}_t}{\sqrt{(m_x-\bar{x}_t)^2 + (m_y-\bar{y}_t)^2}} &amp; \frac{-m_y+\bar{y}_t}{\sqrt{(m_x-\bar{x}_t)^2 + (m_y-\bar{y}_t)^2}} &amp; 0 \\
-1 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp; 0
\end{pmatrix}</code></pre><script type="math/tex; mode=display">% <![CDATA[ H_t = \frac{\partial \mathbf{z_t}}{\partial \mathbf{\bar{x}_t}} = \begin{pmatrix} \frac{-m_x+\bar{x}_t}{\sqrt{(m_x-\bar{x}_t)^2 + (m_y-\bar{y}_t)^2}} & \frac{-m_y+\bar{y}_t}{\sqrt{(m_x-\bar{x}_t)^2 + (m_y-\bar{y}_t)^2}} & 0 \\ -1 & 0 & 0 \\ 0 & -1 & 0 \end{pmatrix} %]]></script><p>따라서 위에서 계산한 Jacobian <code class="MathJax_Preview">H_t</code><script type="math/tex">H_t</script>를 이용하여 EKF의 correction step을 수행할 수 있다. Observation model에서 <code class="MathJax_Preview">Q_t</code><script type="math/tex">Q_t</script>는 measurement 노이즈로, 데이터를 얻는 센서의 부정확성으로 인해 발생한다. 따라서 observation model에서 <code class="MathJax_Preview">Q_t</code><script type="math/tex">Q_t</script>는 센서의 uncertainty자체를 의미한다. 추가적으로 Jacobian matrix는 선형화 포인트에서만 유효하기 때문에 매 step마다 다시 계산해 주어야 한다는 점을 기억해야 한다.<p>다음 글은 EKF를 이용한 SLAM에 대해서 설명한다.<p><strong>본 글을 참조하실 때에는 출처 명시 부탁드립니다.</strong></article><aside class="comments" role="complementary"><h2>Comments</h2><div id="disqus_thread"></div><script> /* var disqus_config = function () { this.page.url = 'http://localhost:4000http://JinyongJeong.github.io/2017/02/15/lec04_EKF_example/'; this.page.identifier = '/2017/02/15/lec04_EKF_example/'; }; */ var loaded = false; var disqus_thread_offsetTop = document.getElementById('disqus_thread').offsetTop; window.addEventListener('scroll', function (e) { if (!loaded && document.body.scrollTop + window.innerHeight >= disqus_thread_offsetTop) { loaded = true; var d = document, s = d.createElement('script'); s.src = '//jinyongjeong.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); } }); </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript></aside><aside class="related" role="complementary"><h2>Related Posts</h2><ul class="related-posts"><li> <a href="http://JinyongJeong.github.io/2017/02/14/lec03_kalman_filter_and_EKF/"> <span>[SLAM] Kalman filter and EKF(Extended Kalman Filter)</span> <small><time datetime="2017-02-14T00:00:00+09:00"> 02/14/17 </time></small> </a><li> <a href="http://JinyongJeong.github.io/2017/02/14/lec02_motion_observation_model/"> <span>[SLAM] Motion & Observation model</span> <small><time datetime="2017-02-14T00:00:00+09:00"> 02/14/17 </time></small> </a><li> <a href="http://JinyongJeong.github.io/2017/02/13/lec01_SLAM_bayes_filter/"> <span>[SLAM] Bayes filter(베이즈 필터)</span> <small><time datetime="2017-02-13T00:00:00+09:00"> 02/13/17 </time></small> </a></ul></aside><aside class="author" role="complementary"><h2>About</h2><img class="me" alt="Jinyong Jeong" src="/images/about/profile.jpg" srcset="/images/about/profile.jpg 2x" /><h3 id="jinyong-jeong">Jinyong Jeong</h3><p>[Current]<ul><li>ph.D student<li>Civil and Environmental Engineering(CEE)<li>Korea Advanced Institute of Science and Technology(<a href="http://www.kaist.ac.kr">KAIST</a>)<li>Intelligent Robotic Autonomy and Perception(<a href="http://irap.kaist.ac.kr">IRAP</a>)<li>Research Interest: Autonomous car, SLAM, computer Vision</ul><p>[Previous]<ul><li>2005.02 ~ 2012.08 : Inha university (undergraduate course)<li>2012.08 ~ 2014.08 : KAIST (master course)<li>2014.08 ~ 2015.10 : Defense Agency for Technology and Quality (DTaQ) researcher<li>2016.02 ~ current : KAIST (ph.D course)</ul></aside></main><div id="_backdrop" class="backdrop"></div><header id="_sidebar" class="sidebar" role="banner"><div id="_asidebar" class="container sidebar-sticky"><div class="sidebar-about"><h1 class="font-accent"><a href="http://JinyongJeong.github.io/">Jinyong Jeong</a></h1><p>This blog is to remember what I studied.</div><nav class="sidebar-nav font-accent" role="navigation"><ul><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/tag/post/">All post</a><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/tag/SLAM/">SLAM</a><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/tag/ubuntu/">Ubuntu</a><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/tag/jekyll/">Jekyll</a><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/tag/software/">Software</a><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/tag/math/">Math</a><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/tag/IRAP/">IRAP</a><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/about/">About</a></ul></nav><div class="sidebar-social"><ul><li> <a href="https://facebook.com/jinyong.jeong.399"> <span class="icon-facebook"></span> <span class="sr-only">facebook</span> </a><li> <a href="https://www.youtube.com/channel/UCPuPw9OXrBzYue3Sv4uvVxQ"> <span class="icon-youtube"></span> <span class="sr-only">youtube</span> </a><li> <a href="https://github.com/JinyongJeong"> <span class="icon-github"></span> <span class="sr-only">github</span> </a></ul></div></div></header><!--[if gt IE 8]><!----> <script>loadJSDeferred('http://JinyongJeong.github.io/public/js/hydejack.min.js')</script> <script> WebFontConfig = { google: { families: 'Roboto+Slab:700|PT+Serif:400,400italic,700,700italic'.split('|') }, custom: { families: ['icomoon'], urls: ['http://JinyongJeong.github.io/public/css/icons.css'] }, classes: false, events: false }; </script> <script>loadJSDeferred('https://ajax.googleapis.com/ajax/libs/webfont/1.6.16/webfont.js')</script> <script> window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date; ga('create', 'UA-84025722-2', 'auto'); ga('send', 'pageview'); </script> <script>loadJSDeferred('https://www.google-analytics.com/analytics.js')</script> <!--<![endif]-->
