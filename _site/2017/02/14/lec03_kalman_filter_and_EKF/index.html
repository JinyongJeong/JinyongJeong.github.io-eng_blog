<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"><title>[SLAM] Kalman filter and EKF(Extended Kalman Filter) &middot; Jinyong Jeong</title><meta name="description" content="Kalman filter와 Extended Kalman filter에 대한 설명. "> <!--[if gt IE 8]><!----><style> article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}html,body{margin:0;padding:0}html{line-height:1.65}body{color:#515151;background-color:#fff}a{text-decoration:none}img{display:block;max-width:100%;margin:0 0 1rem}img.lead{max-width:calc(100% + 2rem);width:calc(100% + 2rem);margin-left:calc(-1rem);margin-right:calc(-1rem)}h1,h2,h3,h4,h5,h6{margin-bottom:.5rem;font-weight:600;line-height:1.25;color:#313131;text-rendering:optimizeLegibility}h1{font-size:2rem}h2{margin-top:1rem;font-size:1.5rem}p{margin-top:0;margin-bottom:1rem}p.lead{font-size:1.25rem;font-weight:300}ul,ol,dl{margin-top:0;margin-bottom:1rem}hr{position:relative;margin:1.5rem 0;border:0;border-top:1px solid #eee;border-bottom:1px solid #fff}.container{max-width:38rem;padding-left:1rem;padding-right:1rem;margin-left:auto;margin-right:auto}.page-title,.post-title{color:#303030}.page-title,.post-title{margin-top:0}.post-date{display:block;margin-top:-.25rem;margin-bottom:1rem;color:#9a9a9a;font-weight:bold}.related{padding-top:2rem;padding-bottom:2rem}.related-posts{padding-left:0;list-style:none}.related-posts>li{margin-top:1rem}.related-posts>li>*{font-weight:normal}.message{margin-bottom:1rem;padding:1rem;color:#717171;background-color:#f9f9f9;margin-left:-1rem;margin-right:-1rem}body{padding-left:0.5rem}@media (min-width: 48em){html{font-size:16px}body{padding-left:0}}@media (min-width: 58em){html{font-size:18px}}.sr-only{display:none}.backdrop{display:none}.sidebar{position:relative;z-index:4;padding:2rem 1rem;color:rgba(255,255,255,0.75);background-color:#202020;text-align:left;background-size:cover;background-position:center center;min-height:640px;min-height:100vh;margin-left:-0.5rem}.sidebar a{color:#fff}.sidebar ul{list-style:none;padding-left:0}.sidebar-sticky{position:absolute;right:1rem;bottom:1rem;left:1rem}.sidebar-about>h1{color:#fff;font-size:2rem}.sidebar-nav-item{font-weight:bold;display:block;line-height:1.75;padding:.25rem .1rem;border-top:1px solid rgba(255,255,255,0.23)}.sidebar-social>ul{min-height:3.5rem}.sidebar::before{content:"";position:absolute;top:0;left:0;bottom:0;right:0;background:rgba(32,32,32,0.33);background:-moz-linear-gradient(bottom, rgba(32,32,32,0) 0%, rgba(32,32,32,0.5) 100%);background:-webkit-linear-gradient(bottom, rgba(32,32,32,0) 0%, rgba(32,32,32,0.5) 100%);background:linear-gradient(to bottom, rgba(32,32,32,0) 0%, rgba(32,32,32,0.5) 100%)}@media (min-width: 48em){.sidebar{position:fixed;top:0;left:0;bottom:0;width:18rem;margin-left:0}}.menu{display:block;padding:1.25rem 1.5rem;color:#9a9a9a;border-bottom:none;position:fixed;top:0;left:0;z-index:2}@media (min-width: 48em){.menu{position:absolute;left:-9999px}}@media (min-width: 48em){.menu:focus{left:19.5rem}}@media (min-width: 64em){.menu:focus{left:21.5rem}}.content{padding-top:4rem;padding-bottom:4rem}@media (min-width: 48em){.content{max-width:38rem;margin-left:20rem;margin-right:2rem;border-left:none}}@media (min-width: 64em){.content{margin-left:22rem;margin-right:4rem}}.me{float:right;width:6.5rem;margin-top:-4.8rem;margin-left:1rem;border-radius:100%;position:relative}@media (min-width: 38em){.me{width:7rem;margin-top:-5.05rem}}@media (min-width: 48em){.me{width:6.5rem;margin-top:-4.8rem}}@media (min-width: 58em){.me{width:7rem;margin-top:-5.05rem}}</style><noscript><link rel="stylesheet" href="http://JinyongJeong.github.io/public/css/non-essentials.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab:700|PT+Serif:400,400italic,700,700italic"><link rel="stylesheet" href="http://JinyongJeong.github.io/public/css/icons.css"> </noscript><link rel="preload" href="http://JinyongJeong.github.io/public/css/non-essentials.css" as="style" onload="this.rel='stylesheet'"><style> html { font-family: "PT Serif", Georgia, serif; } :focus { outline-color: #949667; } .font-accent { font-family: "Roboto Slab", "PT Serif", Georgia, serif; } .content a, .related-posts li a:hover { color: #949667; } ::selection { color: #fff; background: #949667; } ::-moz-selection { color: #fff; background: #949667; } .sidebar { background-image: url('/public/img/2.jpg'); }</style><!--<![endif]--><link rel="canonical" href="http://localhost:4000http://JinyongJeong.github.io/2017/02/14/lec03_kalman_filter_and_EKF/" /><link rel="alternate" type="application/atom+xml" title="Jinyong Jeong Atom Feed" href="http://JinyongJeong.github.io/atom.xml"> <script>!function(n,e){function t(n,e){n.onload=function(){this.onerror=this.onload=null,e(null,n)},n.onerror=function(){this.onerror=this.onload=null,e(new Error("Failed to load "+this.src),n)}}function o(n,e){n.onreadystatechange=function(){"complete"!=this.readyState&&"loaded"!=this.readyState||(this.onreadystatechange=null,e(null,n))}}n.isReady=!1,n.loadJSDeferred=function(a,r){function d(){n.isReady=!0;var d=e.createElement("script");d.src=a,r&&(("onload"in d?t:o)(d,r),d.onload||t(d,r));var i=e.getElementsByTagName("script")[0];i.parentNode.insertBefore(d,i)}n.isReady?d():n.addEventListener?n.addEventListener("load",d,!1):n.attachEvent?n.attachEvent("onload",d):n.onload=d}}(window,document); </script> <!--[if lt IE 9]> <script src="https://unpkg.com/html5shiv/dist/html5shiv.min.js"></script> <![endif]--><body> <span class="sr-only">Jump to:</span> <a id="_menu" class="menu" href="#_asidebar"> <span>☰</span> <span class="sr-only">Menu</span> </a><main class="content container" role="main"><article id="post-2017/02/14/lec03_kalman_filter_and_EKF" class="post" role="article"><h1 class="post-title"> [SLAM] Kalman filter and EKF(Extended Kalman Filter)</h1><div class="post-date"> <time datetime="2017-02-14T00:00:00+09:00">02/14/17</time> <span>on <a href="http://JinyongJeong.github.io/tag/SLAM/">SLAM</a></span></div><p class="message">Kalman filter와 Extended Kalman filter에 대한 설명.<hr/><p><strong>본 글은 University Freiburg의 <a href="http://ais.informatik.uni-freiburg.de/teaching/ws13/mapping/">Robot Mapping</a> 강의를 바탕으로 이해하기 쉽도록 정리하려는 목적으로 작성되었습니다. 개인적인 의견을 포함하여 작성되기 때문에 틀린 내용이 있을 수도 있습니다. 틀린 부분은 지적해주시면 확인 후 수정하겠습니다.</strong><p>이번 글에서는 Kalman filter와 Kalman filter의 확장판인 EKF(Extended Kalman Filter)에 대해서 설명한다. 앞의 글에서 설명한 Bayes filter는 로봇의 상태(state)를 추정하기 위한 방법 중에 한가지 이며, 예측(prediction)단계와 보정(correction)단계의 두 단계로 나뉘어 진다.<ul><li>Prediction step</ul><pre class="MathJax_Preview"><code>\overline{bel}(x_t) = \int_{x_{t-1}}p(x_t \mid x_{t-1}, u_{t}) bel(x_{t-1}) dx_{t-1}</code></pre><script type="math/tex; mode=display">\overline{bel}(x_t) = \int_{x_{t-1}}p(x_t \mid x_{t-1}, u_{t}) bel(x_{t-1}) dx_{t-1}</script><ul><li>Correction step</ul><pre class="MathJax_Preview"><code>bel(x_t) = \eta p(z_t \mid x_t)\overline{bel}(x_t)</code></pre><script type="math/tex; mode=display">bel(x_t) = \eta p(z_t \mid x_t)\overline{bel}(x_t)</script><p>Bayes filter에 대한 자세한 설명은 <a href="http://jinyongjeong.github.io/2017/01/14/lec02_motion_observation_model/">이전의 글</a>을 참고하기 바란다.<h3 id="kalman-filter--ekf-extended-kalman-filter">Kalman Filter &amp; EKF (Extended Kalman Filter)</h3><ul><li><p>Kalman filter는 로봇의 state를 추정하기 위해 가장 흔히 사용되는 방법이며, Bayes filter이다. 즉 control input에 의한 prediction 단계와, 센서의 observation를 이용한 correction의 두 단계로 나누어 진다.<li><p>KF (Kalman Filter)와 EKF (Extended Kalman Filter)는 공통적으로 Gaussian 분포를 가정한다. 즉, 위의 Bayes filter는 모든 확률분포에 대한 식이며, 그 중에서 KF와 EKF는 모든 분포(control input, observation 등)를 gaussian으로 가정한다.<li><p>KF는 선형 Gaussian 모델의 경우이며, EKF는 비선형 Gaussian 모델이다.</ul><h3 id="gaussian-분포">Gaussian 분포</h3><ul><li>Gaussian distribution (normal distribution)</ul><pre class="MathJax_Preview"><code>p(x) = \frac{1}{\sqrt{2\sigma^2 \pi}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}</code></pre><script type="math/tex; mode=display">p(x) = \frac{1}{\sqrt{2\sigma^2 \pi}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}</script><ul><li>Multi variable Gaussian distribution</ul><pre class="MathJax_Preview"><code>p(\mathbf{x}) = \frac{1}{\sqrt{det(2\pi \Sigma)}}e^{-\frac{1}{2}(\mathbf{x}-\mu)^T\Sigma^{-1}(\mathbf{x}-\mu)}</code></pre><script type="math/tex; mode=display">p(\mathbf{x}) = \frac{1}{\sqrt{det(2\pi \Sigma)}}e^{-\frac{1}{2}(\mathbf{x}-\mu)^T\Sigma^{-1}(\mathbf{x}-\mu)}</script><p>Gaussian 분포는 single variable과 multi variable의 Gaussian 분포로 표현할 수 있으며, SLAM에서는 Vector를 이용하여 로봇의 상태(state), 센서 입력, 관찰 값 등을 표현하므로 multi variable의 Gaussian을 많이 사용한다. 따라서 Multi variable의 Gaussian 식은 숙지하는 것이 좋다.<h3 id="선형-모델에서-gaussian-분포의-변환-linear-transformation-of-gaussian-distribution">선형 모델에서 Gaussian 분포의 변환 (Linear transformation of Gaussian distribution)</h3><p>가장 기본적인 선형 모델은 다음과 같다.<pre class="MathJax_Preview"><code>Y = AX+B</code></pre><script type="math/tex; mode=display">Y = AX+B</script><p>이 때, 확률변수 X가 Gaussian 분포를 갖고 있으며 다음과 같을 때,<pre class="MathJax_Preview"><code>X \sim \mathcal{N}(\mu_x,\Sigma_x)</code></pre><script type="math/tex; mode=display">X \sim \mathcal{N}(\mu_x,\Sigma_x)</script><p>선형 변환 후의 확률변수인 Y의 분포는 다음과 같다.<pre class="MathJax_Preview"><code>Y \sim \mathcal{N}(A \mu_x+B,A \Sigma_x A^T)</code></pre><script type="math/tex; mode=display">Y \sim \mathcal{N}(A \mu_x+B,A \Sigma_x A^T)</script><h5 id="유도과정">유도과정</h5><p>X의 평균인 <code class="MathJax_Preview">\mu_x</code><script type="math/tex">\mu_x</script> 는 선형 변환에 의해서 <code class="MathJax_Preview">A\mu_x+B</code><script type="math/tex">A\mu_x+B</script>가 되는 것은 직관적으로 이해 할 수 있다. 그렇다면 covariance matrix은 어떻게 유도가 될까? 우선 covariance matrix의 정의로 부터 시작한다.<pre class="MathJax_Preview"><code>\begin{aligned}
\Sigma_y &amp;= E((y-\mu_y)(y-\mu_y)^T)\\
         &amp;= E((y-(A\mu_x+B))(y-(A\mu_x+B))^T)\\
         &amp;= E(((AX+B)-(A\mu_x+B))((AX+B)-(A\mu_x+B))^T)\\
         &amp;= E([A(X-\mu_x)][A(X-\mu_x)]^T)\\
         &amp;= E(A(X-\mu_x)(X-\mu_x)^TA^T)\\
         &amp;= AE((X-\mu_x)(X-\mu_x)^T)A^T\\
         &amp;= A \Sigma_x A^T
\end{aligned}</code></pre><script type="math/tex; mode=display">% <![CDATA[ \begin{aligned} \Sigma_y &= E((y-\mu_y)(y-\mu_y)^T)\\ &= E((y-(A\mu_x+B))(y-(A\mu_x+B))^T)\\ &= E(((AX+B)-(A\mu_x+B))((AX+B)-(A\mu_x+B))^T)\\ &= E([A(X-\mu_x)][A(X-\mu_x)]^T)\\ &= E(A(X-\mu_x)(X-\mu_x)^TA^T)\\ &= AE((X-\mu_x)(X-\mu_x)^T)A^T\\ &= A \Sigma_x A^T \end{aligned} %]]></script><p>위의 유도처럼 Gaussian 분포의 선형변환에서의 covariance는 covariance의 정의로부터 <code class="MathJax_Preview">\Sigma_y = A \Sigma_x A^T</code><script type="math/tex">\Sigma_y = A \Sigma_x A^T</script> 로 정의된다. 이 관계는 Kalman filter 뿐만 아니라 Gaussian을 사용하는 여러 분야에서 자주 사용되므로 기억해 두는것이 좋다.<h3 id="kalman-filter-kf">Kalman Filter (KF)</h3><ul><li>Kalman filter는 선형 모델(Linear model)에서 uncertainty의 분포를 Gaussian으로 가정하였을 때의 solution이다.<li>Kalman filter는 motion 모델과 observation 모델을 선형으로 가정한다.<li>노이즈는 평균(mean)이 0인 Gaussian 분포로 가정한다.</ul><pre class="MathJax_Preview"><code>\begin{aligned}
x_t &amp;= A_t x_{t-1} + B_t u_t + \epsilon_t\\
z_t &amp;= C_t x_t + \delta_t
\end{aligned}</code></pre><script type="math/tex; mode=display">% <![CDATA[ \begin{aligned} x_t &= A_t x_{t-1} + B_t u_t + \epsilon_t\\ z_t &= C_t x_t + \delta_t \end{aligned} %]]></script><ul><li><code class="MathJax_Preview">A_t</code><script type="math/tex">A_t</script> : control input(<code class="MathJax_Preview">u_t</code><script type="math/tex">u_t</script>)과 노이즈(<code class="MathJax_Preview">\epsilon_t</code><script type="math/tex">\epsilon_t</script>)가 없을 때 t-1와 t의 state가 어떻게 관계되어 있는지를 의미하는 n x n matrix.<li><code class="MathJax_Preview">B_t</code><script type="math/tex">B_t</script> : control input(<code class="MathJax_Preview">u_t</code><script type="math/tex">u_t</script>)이 어떻게 state 변화에 영향을 미치는지를 나타내는 n x l matrix.<li><code class="MathJax_Preview">C_t</code><script type="math/tex">C_t</script> : 현재 로봇의 상태를 나타내는 state(<code class="MathJax_Preview">x_t</code><script type="math/tex">x_t</script>)와 센서의 관측 정보(observation)이 어떤 관계인지를 나타내는 k x n matrix.<li><code class="MathJax_Preview">\epsilon_t, \delta_t</code><script type="math/tex">\epsilon_t, \delta_t</script> : 평균이 0이며 covariance가 각각 <code class="MathJax_Preview">R_t, Q_t</code><script type="math/tex">R_t, Q_t</script>인 확률변수이며, process noise와 measurement noise를 의미한다.</ul><p>여기서 구별해야 할 점은 <code class="MathJax_Preview">R_t</code><script type="math/tex">R_t</script>는 input의 noise가 아닌 process의 noise이다. <code class="MathJax_Preview">R_t</code><script type="math/tex">R_t</script>는 control input에서 들어오는 Gaussian noise가 한번의 선형 변환을 거친 전체 state인 <code class="MathJax_Preview">x_t</code><script type="math/tex">x_t</script>의 noise 이므로 process noise라고 부른다. 이때 control input인 <code class="MathJax_Preview">u_t</code><script type="math/tex">u_t</script>의 covariance는 <code class="MathJax_Preview">M_t</code><script type="math/tex">M_t</script>라고 표기한다.<p>위의 선형 모델을 이용한 motion model과 observation model은 다음과 같다.<ul><li>Motion model</ul><pre class="MathJax_Preview"><code>p(x_t \mid u_t, x_{t-1}) = \frac{1}{\sqrt{det(2\pi R_t)}}e^{-\frac{1}{2}(x_t-A_t x_{t-1} - B_t u_t)^TR_t^{-1}(x_t-A_t x_{t-1} - B_t u_t)}</code></pre><script type="math/tex; mode=display">p(x_t \mid u_t, x_{t-1}) = \frac{1}{\sqrt{det(2\pi R_t)}}e^{-\frac{1}{2}(x_t-A_t x_{t-1} - B_t u_t)^TR_t^{-1}(x_t-A_t x_{t-1} - B_t u_t)}</script><ul><li>Observation model</ul><pre class="MathJax_Preview"><code>p(z_t \mid x_t) = \frac{1}{\sqrt{det(2\pi Q_t)}}e^{-\frac{1}{2}(z_t-C_t x_{t})^T Q_t^{-1}(z_t-C_t x_{t})}</code></pre><script type="math/tex; mode=display">p(z_t \mid x_t) = \frac{1}{\sqrt{det(2\pi Q_t)}}e^{-\frac{1}{2}(z_t-C_t x_{t})^T Q_t^{-1}(z_t-C_t x_{t})}</script><p>Motion model은 prediction step에서, observation model은 correction step에 적용된다.<ul><li>Prediction step</ul><pre class="MathJax_Preview"><code>\overline{bel}(x_t) = \int_{x_{t-1}}p(x_t \mid x_{t-1}, u_{t}) bel(x_{t-1}) dx_{t-1}</code></pre><script type="math/tex; mode=display">\overline{bel}(x_t) = \int_{x_{t-1}}p(x_t \mid x_{t-1}, u_{t}) bel(x_{t-1}) dx_{t-1}</script><ul><li>Correction step</ul><pre class="MathJax_Preview"><code>bel(x_t) = \eta p(z_t \mid x_t)\overline{bel}(x_t)</code></pre><script type="math/tex; mode=display">bel(x_t) = \eta p(z_t \mid x_t)\overline{bel}(x_t)</script><p>t-1에서의 state의 확률은 motion model에 의해 t의 state의 확률이 결정되며(prediction step), prediction step에서 계산된 t에서의 state의 확률은 observation model에 의해서 보정된다. 이와같은 bayes filter식은 여러 확률 모델 분포를 모두 포함하고 있는 식이며, 그 중에서 모든 확률 분포를 Gaussian 확률 분포로 가정하는 모델이 Kalman filter이다. Gaussian으로 확률분포를 표현할 때, 간단히 평균(mean, <code class="MathJax_Preview">\mu</code><script type="math/tex">\mu</script>)와 분산(variance, <code class="MathJax_Preview">\Sigma</code><script type="math/tex">\Sigma</script>)으로 표현하기 때문에 두개의 파라미터만으로 분포를 표현할 수 있는 장점이 있다. Kalman filter 알고리즘은 다음과 같다.<pre class="MathJax_Preview"><code>\begin{aligned}
1: &amp; Kalman filter(\mu_{t-1}, \Sigma_{t-1}, u_t, z_t)\\
&amp;[Prediction step]\\
2: &amp; \ \ \bar{\mu}_t = A_t \mu_{t-1} + B_t u_t\\
3: &amp;\ \ \bar{\Sigma_t} = A_t \Sigma_{t-1} A_t^T + R_t\\
&amp;[Correction step]\\
4: &amp;\ \ K_t = \bar{\Sigma_t}C_t^T(C_t \bar{\Sigma_t}C_t^T + Q_t)^{-1}\\
5: &amp;\ \ \mu_t = \bar{\mu_t} + K_t(z_t - C_t \bar{\mu_t})\\
6: &amp;\ \ \Sigma_t = (I - K_t C_t)\bar{\Sigma_t}\\
7: &amp;\ \ return \ \ \mu_t, \Sigma_t\\
\end{aligned}</code></pre><script type="math/tex; mode=display">% <![CDATA[ \begin{aligned} 1: & Kalman filter(\mu_{t-1}, \Sigma_{t-1}, u_t, z_t)\\ &[Prediction step]\\ 2: & \ \ \bar{\mu}_t = A_t \mu_{t-1} + B_t u_t\\ 3: &\ \ \bar{\Sigma_t} = A_t \Sigma_{t-1} A_t^T + R_t\\ &[Correction step]\\ 4: &\ \ K_t = \bar{\Sigma_t}C_t^T(C_t \bar{\Sigma_t}C_t^T + Q_t)^{-1}\\ 5: &\ \ \mu_t = \bar{\mu_t} + K_t(z_t - C_t \bar{\mu_t})\\ 6: &\ \ \Sigma_t = (I - K_t C_t)\bar{\Sigma_t}\\ 7: &\ \ return \ \ \mu_t, \Sigma_t\\ \end{aligned} %]]></script><p>위 식은 Kalman filter algorithm을 보여주고 있다. Kalman filter는 bayes filter이기 때문에 prediction과 correction의 두 단계로 이루어 지며, 다소 복잡해 보이지만 한단계씩 이해하면 어렵지 않다.<ul><li>Prediction step (Kalman filter)</ul><p>첫번째 prediction 단계는 복잡하지 않다. 직관적으로 t-1의 평균은 motion model을 통해 t의 평균으로 계산되어 진다(2). 이때 <code class="MathJax_Preview">\mu, \Sigma</code><script type="math/tex">\mu, \Sigma</script>에 붙어있는 bar(<code class="MathJax_Preview">\bar{\mu}, \bar{\Sigma}</code><script type="math/tex">\bar{\mu}, \bar{\Sigma}</script>)는 prediction step임을 의미한다. 그 다음으로 covariance는 위에서 설명한 Gaussian linear transformation의 의해 계산되어 진다(3). 이때 <code class="MathJax_Preview">R_t</code><script type="math/tex">R_t</script>는 process noise 이며, control input(<code class="MathJax_Preview">u_t</code><script type="math/tex">u_t</script>)의 covariance가 <code class="MathJax_Preview">M_t</code><script type="math/tex">M_t</script>일 때 <code class="MathJax_Preview">R_t = B_t M_t B_t^T</code><script type="math/tex">R_t = B_t M_t B_t^T</script>이다. 일반적인 로봇시스템이나 자동차 시스템에서 control input은 wheel encoder로 부터 얻어지는 odometry 정보를 많이 이용하며, encoder 센서의 uncertainty가 <code class="MathJax_Preview">M_t</code><script type="math/tex">M_t</script>가 된다.<ul><li>Correction step (Kalman filter)</ul><p>Correction 단계에서는 새로운 변수인 K(Kalman gain)이 추가된다. K는 현재 관측 데이터(<code class="MathJax_Preview">z_t</code><script type="math/tex">z_t</script>)의 정확도에 따라 predicted state와 관측된 state(observation model을 이용하여 관측값으로부터 추정된 state)의 보정 비율을 결정하는 역활을 한다. 이때 <code class="MathJax_Preview">Q_t</code><script type="math/tex">Q_t</script>가 observation의 covariance이다. 5번 식에서 (<code class="MathJax_Preview">z_t - C_t\bar{\mu_t}</code><script type="math/tex">z_t - C_t\bar{\mu_t}</script>)는 현재 실제로 관측된 데이터(<code class="MathJax_Preview">z_t</code><script type="math/tex">z_t</script>)와 현재 위치로 예상되는 위치(<code class="MathJax_Preview">\bar{\mu_t}</code><script type="math/tex">\bar{\mu_t}</script>)에서 기대되는 관측값(<code class="MathJax_Preview">C_t\bar{\mu_t}</code><script type="math/tex">C_t\bar{\mu_t}</script>)과의 차이를 Kalman gain(K)의 크기만큼 보정함으로써, 최종 Gaussian의 평균을 계산한다. 쉬운 이해를 돕기 위해 예를 들어보자. 우리의 로봇은 로봇의 위치에서 부터 주변 lanemark까지의 거리를 측정할 수 있는 로봇이라고 하자. 만약 encoder data와 motion model에 의해서 예상되는 로봇의 위치를 알고 있고, 주변의 lanemark의 위치를 이미 알고 있을 때, 예상되는 lanemark까지의 거리를 계산할 수 있다. 만약 이 예상되는 거리가 10m인데, 실제 lanemark까지의 거리가 9m로 측정이 된다면, 두 값이 오차인 1m는 odometry sensor로 부터 발생한 것일 수 도 있고, 거리를 측정하는 센서로 부터 발생한 것일 수도 있다. 이때 Kalman gain은 10m와 9m중 어느 데이터를 더 신뢰할지를 결정하는 파라미터로 볼 수 있다.<p>조금 더 쉽게 이해하기 위해 observation의 covariance인 <code class="MathJax_Preview">Q_t</code><script type="math/tex">Q_t</script>가 무한대라고 해보자. covariance가 무한대라는 의미는 거리측정 센서로부터 얻어진 데이터는 전혀 신뢰 할 수 없다는 것을 의미한다. 이때 K는 0이 되며, <code class="MathJax_Preview">\mu_t = \bar{\mu_t}</code><script type="math/tex">\mu_t = \bar{\mu_t}</script>가 된다. 즉, 관측된 센서 데이터는 신뢰할 수 없으므로, 예측된 로봇의 위치를 전적으로 신뢰하겠다는 것이다. 반대로 <code class="MathJax_Preview">Q_t</code><script type="math/tex">Q_t</script>가 0라고 해보자. Covariance가 0이라는 의미는 센서 데이터를 100% 신뢰할 수 있음을 의미한다. 따라서 <code class="MathJax_Preview">Q_t</code><script type="math/tex">Q_t</script>가 0이라면 <code class="MathJax_Preview">K = C_t^{-1}</code><script type="math/tex">K = C_t^{-1}</script>이 되며, 5번식은 <code class="MathJax_Preview">\mu_t = C_t^{-1} z_t</code><script type="math/tex">\mu_t = C_t^{-1} z_t</script>가 된다. 즉 로봇의 거리 측정센서로 부터 얻어진 데이터(<code class="MathJax_Preview">z_t</code><script type="math/tex">z_t</script>)를 전적으로 신뢰하여, 이로부터 로봇의 state를 추정하겠다는 의미이다. 6번식 covariace를 계산하는 부분도 이와 마찬가지로 <code class="MathJax_Preview">Q_t</code><script type="math/tex">Q_t</script>가 무한대 일때는 최종 covariace는 prediction의 covariance를 그대로 사용하며, <code class="MathJax_Preview">Q_t</code><script type="math/tex">Q_t</script>가 0일때는 관측데이터가 100%신뢰할 수 있음을 의미하므로 covariace는 0이 된다.<p><img align="middle" src="/images/post/SLAM/lec03_kalman_filter_and_EKF/kalman_fig.png" width="700" /><p>위 그림은 Kalman filter의 과정을 그림으로 표현하였다. 빨간색은 그래프는 prediction step에서 계산한 state의 Gaussian, 초록색은 observation으로 추정한 state의 Gaussian 분포이다. Kalman filter algorithm의 계산에 의해 두 Gaussian분포는 파란색의 최종 Gaussian 분포로 state가 결정된다. 이때 초록색 Gaussian의 variance가 빨간색보다 작기 때문에, 최종 결과는 measurement에 더욱 dominant하다.<h3 id="extended-kalman-filter-ekf">Extended Kalman Filter (EKF)</h3><ul><li>KF와 마찬가지로 노이즈는 평균(mean)이 0인 Gaussian 분포로 가정한다.<li>KF와의 차이점은 motion 모델과 observation 모델을 선형으로 가정하지 않고 비선형 함수로 확장한 것이다.<li>거의 대부분의 실제 시스템은 비선형이다.</ul><p>Extended Kalman Filter는 아래와 같이 기존 KF의 선형 모델을 비선형 함수인 <code class="MathJax_Preview">g(u_t,x_{t-1})</code><script type="math/tex">g(u_t,x_{t-1})</script>와 <code class="MathJax_Preview">h(x_t)</code><script type="math/tex">h(x_t)</script>로 바꿈으로써 비선형으로 확장한 모델이다.<pre class="MathJax_Preview"><code>\begin{aligned}
x_t &amp;= g(u_t, x_{t-1}) + \epsilon_t &amp;\leftarrow &amp;x_t = A_t x_{t-1} + B_t u_t + \epsilon_t\\
z_t &amp;= h(x_t) + \delta_t            &amp;\leftarrow &amp;z_t = C_t x_t + \delta_t
\end{aligned}</code></pre><script type="math/tex; mode=display">% <![CDATA[ \begin{aligned} x_t &= g(u_t, x_{t-1}) + \epsilon_t &\leftarrow &x_t = A_t x_{t-1} + B_t u_t + \epsilon_t\\ z_t &= h(x_t) + \delta_t &\leftarrow &z_t = C_t x_t + \delta_t \end{aligned} %]]></script><p>하지만 motion 모델과 observation 모델을 비선형으로 확장한 경우 문제가 발생한다. 다음 그림은 이러한 문제를 보여준다.<div style="width:43%; float:left; margin-right:3px;"> <img align="left" src="/images/post/SLAM/lec03_kalman_filter_and_EKF/linear.png" /></div><div style="width:54%; float:left;"> <img align="left" src="/images/post/SLAM/lec03_kalman_filter_and_EKF/non_linear.png" /></div><div style="clear:both;"></div><p>많은 문제에서 Gaussian 분포를 사용하는 이유는 평균(mean)과 분산(variance) 두개의 파라미터로 분포를 표현함과 동시에 데이터들의 분포를 정확히 반영할 수 있기 때문이다. 따라서 반복적인 계산을 통해 state를 추정하는 문제에서 입력이 Gaussian 분포일 때 출력 또한 Gaussian 분포이여야 한다. 왼쪽 그림은 선형 시스템에서의 입력과 출력을 보여준다. 선형 시스템이기 때문에 입력이 Gaussian 분포일 때 출력 또한 Gaussian 분포가 된다. 하지만 오른쪽 그림과 같이 비선형 시스템의 경우, 입력은 Gaussian 분포이지만 시스템의 비선형성에 의해 출력은 Gaussian 분포가 아니다. 따라서 이런 경우 출력을 평균과 분산으로 표현 할 수 없다. 이러한 문제를 풀기 위해서는 비선형함수를 선형화(Linearization) 시키는 과정이 필요하다.<h5 id="선형화linearization">선형화(Linearization)</h5><p>EKF에서 비선형 함수를 선형화 시키기 위해서는 1차 Taylor 근사법(First order Talyer Expansion)을 사용한다. 선형 근사화된 model은 다음과 같다.<ul><li>Motion model</ul><pre class="MathJax_Preview"><code>g(u_t, x_{t-1}) \approx g(u_t,\mu_{t-1}) + \frac{\partial g(u_t, \mu_{t-1})}{\partial x_{t-1}}(x_{t-1} - \mu_{t-1})</code></pre><script type="math/tex; mode=display">g(u_t, x_{t-1}) \approx g(u_t,\mu_{t-1}) + \frac{\partial g(u_t, \mu_{t-1})}{\partial x_{t-1}}(x_{t-1} - \mu_{t-1})</script><ul><li>Observation model</ul><pre class="MathJax_Preview"><code>h(x_t) \approx h(\bar{\mu_t}) + \frac{\partial h(\bar{\mu_t})}{\partial x_t} (x_t - \bar{\mu_t})</code></pre><script type="math/tex; mode=display">h(x_t) \approx h(\bar{\mu_t}) + \frac{\partial h(\bar{\mu_t})}{\partial x_t} (x_t - \bar{\mu_t})</script><p>이떄 비선형 함수들을 state로 편미분하여 matrix를 생성하는데 이 matrix를 <strong>Jacobian</strong> 이라고 부르며, 두 matrix는 <code class="MathJax_Preview">G_t = \frac{\partial g(u_t, \mu_{t-1})}{\partial x_{t-1}}</code><script type="math/tex">G_t = \frac{\partial g(u_t, \mu_{t-1})}{\partial x_{t-1}}</script>, <code class="MathJax_Preview">H_t = \frac{\partial h(\bar{\mu_t})}{\partial x_t}</code><script type="math/tex">H_t = \frac{\partial h(\bar{\mu_t})}{\partial x_t}</script>로 표기한다.<h5 id="jacobian-matrix">Jacobian matrix</h5><ul><li>Jacobian matrix는 non-square matrix이다.<li>비선형 함수 vector가 <code class="MathJax_Preview">g(x)</code><script type="math/tex">g(x)</script>일 때 Jacobian <code class="MathJax_Preview">G_x</code><script type="math/tex">G_x</script>는 다음과 같이 계산된다.</ul><pre class="MathJax_Preview"><code>g(x) =
\begin{bmatrix}
g_1(x)\\
g_2(x)\\
\vdots\\
g_m(x)
\end{bmatrix}</code></pre><script type="math/tex; mode=display">g(x) = \begin{bmatrix} g_1(x)\\ g_2(x)\\ \vdots\\ g_m(x) \end{bmatrix}</script><pre class="MathJax_Preview"><code>G_x =
\begin{bmatrix}
\frac{\partial g_1}{\partial x_1} &amp; \frac{\partial g_1}{\partial x_2} &amp; \cdots &amp; \frac{\partial g_1}{\partial x_n}\\
\frac{\partial g_2}{\partial x_1} &amp; \frac{\partial g_2}{\partial x_2} &amp; \cdots &amp; \frac{\partial g_2}{\partial x_n}\\
\vdots &amp; \vdots &amp; &amp; \vdots\\
\frac{\partial g_m}{\partial x_1} &amp; \frac{\partial g_m}{\partial x_2} &amp; \cdots &amp; \frac{\partial g_m}{\partial x_n}
\end{bmatrix}</code></pre><script type="math/tex; mode=display">% <![CDATA[ G_x = \begin{bmatrix} \frac{\partial g_1}{\partial x_1} & \frac{\partial g_1}{\partial x_2} & \cdots & \frac{\partial g_1}{\partial x_n}\\ \frac{\partial g_2}{\partial x_1} & \frac{\partial g_2}{\partial x_2} & \cdots & \frac{\partial g_2}{\partial x_n}\\ \vdots & \vdots & & \vdots\\ \frac{\partial g_m}{\partial x_1} & \frac{\partial g_m}{\partial x_2} & \cdots & \frac{\partial g_m}{\partial x_n} \end{bmatrix} %]]></script><p>아래 그림은 Talyer 근사화를 통해 선형화를 하였을 때의 특징을 보여준다.<div style="width:48%; float:left; margin-right:3px;"> <img align="left" src="/images/post/SLAM/lec03_kalman_filter_and_EKF/large_variance.png" /></div><div style="width:48%; float:left;"> <img align="left" src="/images/post/SLAM/lec03_kalman_filter_and_EKF/small_variance.png" /></div><div style="clear:both;"></div><p>왼쪽그림은 입력의 분산(variance)가 큰 경우를 보여주며, 오른쪽 그림은 분산이 작은 경우를 보여준다. 분산이 큰 경우 실제 비선형 함수 출력의 평균값과 선형화를 통해 계산된 평균값의 차이가 큰 것을 알 수 있다. 반면 분산이 작은 경우는 선형화를 통해 계산된 평균값이 실제 평균값과 유사함을 알 수 있다. 따라서 선형화 시 선형화 지점으로 부터 멀수록(분산이 클수록) 실제 함수를 반영하지 못한다.<h5 id="ekf-algorithm">EKF algorithm</h5><p>선형화된 motion 모델과 observation 모델을 이용한 bayes filter는 다음과 같다.<ul><li>linearized prediction model</ul><pre class="MathJax_Preview"><code>p(x_t \mid u_t, x_{t-1}) \approx \frac{1}{\sqrt{det(2\pi R_t)}}e^{-\frac{1}{2}(x_t-g(u_t, \mu_{t-1}) - G_t(x_{t-1} - \mu_{t-1}))^TR_t^{-1}(x_t-g(u_t, \mu_{t-1}) - G_t(x_{t-1} - \mu_{t-1}))}</code></pre><script type="math/tex; mode=display">p(x_t \mid u_t, x_{t-1}) \approx \frac{1}{\sqrt{det(2\pi R_t)}}e^{-\frac{1}{2}(x_t-g(u_t, \mu_{t-1}) - G_t(x_{t-1} - \mu_{t-1}))^TR_t^{-1}(x_t-g(u_t, \mu_{t-1}) - G_t(x_{t-1} - \mu_{t-1}))}</script><ul><li>linearized correction model</ul><pre class="MathJax_Preview"><code>p(z_t \mid x_t) \approx \frac{1}{\sqrt{det(2\pi Q_t)}}e^{-\frac{1}{2}(z_t-h(\bar{\mu_t})-H_t (x_t-\bar{\mu_t}))^T Q_t^{-1}(z_t-h(\bar{\mu_t})-H_t (x_t-\bar{\mu_t}))}</code></pre><script type="math/tex; mode=display">p(z_t \mid x_t) \approx \frac{1}{\sqrt{det(2\pi Q_t)}}e^{-\frac{1}{2}(z_t-h(\bar{\mu_t})-H_t (x_t-\bar{\mu_t}))^T Q_t^{-1}(z_t-h(\bar{\mu_t})-H_t (x_t-\bar{\mu_t}))}</script><p>KF와 마찬가지로 <code class="MathJax_Preview">R_t, Q_t</code><script type="math/tex">R_t, Q_t</script>는 process noise와 measurement noise이다. EKF 알고리즘은 다음과 같다.<pre class="MathJax_Preview"><code>\begin{aligned}
1: &amp; Extended Kalman filter(\mu_{t-1}, \Sigma_{t-1}, u_t, z_t)\\
&amp;[Prediction step]\\
2: &amp; \ \ \bar{\mu}_t = g(u_t, \mu_{t-1})\\
3: &amp;\ \ \bar{\Sigma_t} = G_t \Sigma_{t-1} G_t^T + R_t\\
&amp;[Correction step]\\
4: &amp;\ \ K_t = \bar{\Sigma_t}H_t^T(H_t \bar{\Sigma_t}H_t^T + Q_t)^{-1}\\
5: &amp;\ \ \mu_t = \bar{\mu_t} + K_t(z_t - h(\bar{\mu_t}))\\
6: &amp;\ \ \Sigma_t = (I - K_t C_t)\bar{\Sigma_t}\\
7: &amp;\ \ return \ \ \mu_t, \Sigma_t\\
\end{aligned}</code></pre><script type="math/tex; mode=display">% <![CDATA[ \begin{aligned} 1: & Extended Kalman filter(\mu_{t-1}, \Sigma_{t-1}, u_t, z_t)\\ &[Prediction step]\\ 2: & \ \ \bar{\mu}_t = g(u_t, \mu_{t-1})\\ 3: &\ \ \bar{\Sigma_t} = G_t \Sigma_{t-1} G_t^T + R_t\\ &[Correction step]\\ 4: &\ \ K_t = \bar{\Sigma_t}H_t^T(H_t \bar{\Sigma_t}H_t^T + Q_t)^{-1}\\ 5: &\ \ \mu_t = \bar{\mu_t} + K_t(z_t - h(\bar{\mu_t}))\\ 6: &\ \ \Sigma_t = (I - K_t C_t)\bar{\Sigma_t}\\ 7: &\ \ return \ \ \mu_t, \Sigma_t\\ \end{aligned} %]]></script><p>EKF 알고리즘과 KF 알고리즘의 차이는 KF에서 선형함수를 통해 평균(<code class="MathJax_Preview">\mu</code><script type="math/tex">\mu</script>)를 구하는 2,5번 식에서 선형함수 대신 비선형 함수가 사용되었다. 그리고 3,4번 식에서 선형함수의 <code class="MathJax_Preview">A_t, C_t</code><script type="math/tex">A_t, C_t</script> Matrix는 Jacobian matrix인 <code class="MathJax_Preview">G_t, H_t</code><script type="math/tex">G_t, H_t</script>로 수정되었다. 여기서 <code class="MathJax_Preview">R_t</code><script type="math/tex">R_t</script>는 process noise이며, control input의 covariance matrix가 <code class="MathJax_Preview">M_t</code><script type="math/tex">M_t</script>일 때 <code class="MathJax_Preview">R_t = V_t M_t V_t^T</code><script type="math/tex">R_t = V_t M_t V_t^T</script>이다. 여기서 <code class="MathJax_Preview">V_t</code><script type="math/tex">V_t</script>는 <code class="MathJax_Preview">g(u_t,\mu_{t-1})</code><script type="math/tex">g(u_t,\mu_{t-1})</script>를 control input인 <code class="MathJax_Preview">u_t</code><script type="math/tex">u_t</script>로 편미분한 Jacobian이다.<p>여기까지 EKF에 대한 설명을 마친다. 다음 글에서는 실제 robot의 모델을 통해 EKF를 이해해보자.<p><strong>본 글을 참조하실 때에는 출처 명시 부탁드립니다.</strong></article><aside class="comments" role="complementary"><h2>Comments</h2><div id="disqus_thread"></div><script> /* var disqus_config = function () { this.page.url = 'http://localhost:4000http://JinyongJeong.github.io/2017/02/14/lec03_kalman_filter_and_EKF/'; this.page.identifier = '/2017/02/14/lec03_kalman_filter_and_EKF/'; }; */ var loaded = false; var disqus_thread_offsetTop = document.getElementById('disqus_thread').offsetTop; window.addEventListener('scroll', function (e) { if (!loaded && document.body.scrollTop + window.innerHeight >= disqus_thread_offsetTop) { loaded = true; var d = document, s = d.createElement('script'); s.src = '//jinyongjeong.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); } }); </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript></aside><aside class="related" role="complementary"><h2>Related Posts</h2><ul class="related-posts"><li> <a href="http://JinyongJeong.github.io/2017/02/15/lec04_EKF_example/"> <span>[SLAM] Extended Kalman Filter(EKF) 예제</span> <small><time datetime="2017-02-15T00:00:00+09:00"> 02/15/17 </time></small> </a><li> <a href="http://JinyongJeong.github.io/2017/02/14/lec02_motion_observation_model/"> <span>[SLAM] Motion & Observation model</span> <small><time datetime="2017-02-14T00:00:00+09:00"> 02/14/17 </time></small> </a><li> <a href="http://JinyongJeong.github.io/2017/02/13/lec01_SLAM_bayes_filter/"> <span>[SLAM] Bayes filter(베이즈 필터)</span> <small><time datetime="2017-02-13T00:00:00+09:00"> 02/13/17 </time></small> </a></ul></aside><aside class="author" role="complementary"><h2>About</h2><img class="me" alt="Jinyong Jeong" src="/images/about/profile.jpg" srcset="/images/about/profile.jpg 2x" /><h3 id="jinyong-jeong">Jinyong Jeong</h3><p>[Current]<ul><li>ph.D student<li>Civil and Environmental Engineering(CEE)<li>Korea Advanced Institute of Science and Technology(<a href="http://www.kaist.ac.kr">KAIST</a>)<li>Intelligent Robotic Autonomy and Perception(<a href="http://irap.kaist.ac.kr">IRAP</a>)<li>Research Interest: Autonomous car, SLAM, computer Vision</ul><p>[Previous]<ul><li>2005.02 ~ 2012.08 : Inha university (undergraduate course)<li>2012.08 ~ 2014.08 : KAIST (master course)<li>2014.08 ~ 2015.10 : Defense Agency for Technology and Quality (DTaQ) researcher<li>2016.02 ~ current : KAIST (ph.D course)</ul></aside></main><div id="_backdrop" class="backdrop"></div><header id="_sidebar" class="sidebar" role="banner"><div id="_asidebar" class="container sidebar-sticky"><div class="sidebar-about"><h1 class="font-accent"><a href="http://JinyongJeong.github.io/">Jinyong Jeong</a></h1><p>This blog is to remember what I studied.</div><nav class="sidebar-nav font-accent" role="navigation"><ul><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/tag/post/">All post</a><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/tag/SLAM/">SLAM</a><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/tag/ubuntu/">Ubuntu</a><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/tag/jekyll/">Jekyll</a><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/tag/software/">Software</a><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/tag/math/">Math</a><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/tag/IRAP/">IRAP</a><li> <a class="sidebar-nav-item " href="http://JinyongJeong.github.io/about/">About</a></ul></nav><div class="sidebar-social"><ul><li> <a href="https://facebook.com/jinyong.jeong.399"> <span class="icon-facebook"></span> <span class="sr-only">facebook</span> </a><li> <a href="https://www.youtube.com/channel/UCPuPw9OXrBzYue3Sv4uvVxQ"> <span class="icon-youtube"></span> <span class="sr-only">youtube</span> </a><li> <a href="https://github.com/JinyongJeong"> <span class="icon-github"></span> <span class="sr-only">github</span> </a></ul></div></div></header><!--[if gt IE 8]><!----> <script>loadJSDeferred('http://JinyongJeong.github.io/public/js/hydejack.min.js')</script> <script> WebFontConfig = { google: { families: 'Roboto+Slab:700|PT+Serif:400,400italic,700,700italic'.split('|') }, custom: { families: ['icomoon'], urls: ['http://JinyongJeong.github.io/public/css/icons.css'] }, classes: false, events: false }; </script> <script>loadJSDeferred('https://ajax.googleapis.com/ajax/libs/webfont/1.6.16/webfont.js')</script> <script> window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date; ga('create', 'UA-84025722-2', 'auto'); ga('send', 'pageview'); </script> <script>loadJSDeferred('https://www.google-analytics.com/analytics.js')</script> <!--<![endif]-->
